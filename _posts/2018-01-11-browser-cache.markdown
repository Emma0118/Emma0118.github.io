---
layout: post
title: 浏览器缓存小结
date: 2016-01-11 15:32:24.000000000 +09:00
---
## 缓存分类
广义的web缓存包含很多种，常见的比如数据库缓存、代理服务器缓存、CDN缓存、和今天要讨论的浏览器缓存。
浏览器缓存是提高网页性能和用户体验以及减少服务器处理请求的重要方式，其实现方式主要通过在会话过程中通过检查缓存的文件是否足够新来判断获取数据的方式，并且在后退网页时，访问过的资源直接从缓存中获取



## 浏览器缓存及基本认知
**浏览器缓存分为强缓存和协商缓存**。
浏览器通过http header判断实行强缓存策略还是协商缓存策略，其基本如下：
1.浏览器在加载资源时，会首先根据http headers的Expires或Cache-control判断它是否满足强缓存，如果满足，浏览器直接从自己的缓存中读取资源，不会发送任何请求
2.如果不满足强缓存，浏览器则发送请求道服务器，服务器根据request headers验证请求的资源是否满足协商缓存，如果满足，服务器会返回请求，但是不会携带浏览器请求的资源，而是告诉浏览器可以直接从缓存中加载资源，于是浏览器又从自己的缓存中去加载这个资源。
如果满足强缓存或者协商缓存，浏览器都会从客户端缓存中加载资源；但是强缓存并不会发送请求道服务器，而协商缓存会发送一个请求到服务器。
如果两种缓存都不满足，浏览器只能直接从服务器加载资源数据。

## 强缓存

### 强缓存原理及应用
1.首先，浏览器第一次跟服务器请求资源时，服务器在返回资源的同时，在response的headers里会加上Expires或Cache-control，表示资源在客户端缓存的有效期，其中，Expires是绝对时间，是一个较老的缓存管理header，当服务器的时间和客户端的时间相差较大时，容易出现错误，比如，当手动修改客户端时间时，会影响缓存命中的结果。Cache-control是相对时间， 在http1.1中提出，以秒为单位。
这两个header可以只启用一个，也可以同时启用，由于Cache-control的缓存管理更有效更安全，所以当同时启用时，Cache-control的优先级高于Expires。
2.浏览器在接收到资源后，会将资源和response header 一起缓存起来；
3.当浏览器再次请求统一资源时，先从缓存中寻找，根据它第一次请求时间和Cache-control设定的有效期，计算出一个资源过期时间，再拿这个过期时间和当前请求时间比较，如果请求时间再过期时间之前，就命中缓存，否则就不行。<
4.如果缓存没有命中，浏览器直接从服务器加载资源时，Cache-control header 在重新加载时会被更新。
### 强缓存管理和设置
一般可以使用2种方式来设置是有启用强缓存
1. 通过代码的方式，在web服务器返回的响应中添加 Expires 和 Cache-Control Header;
比如在PHP接口中，header('Cache-Control: max-age=3600*24');
2. 通过配置web服务器的方式，让web服务器在响应资源的时候统一添加  Expires 和 Cache-Control Header;
比如在nginx的config文件中，
```bash
1    # 相关页面设置Cache-Control头信息,dns及cdn目录配置10天
2
3    if ($request_uri ~* "^/$|^/dns/.+/|^/cdn/.+/") {
4      add_header    Cache-Control  max-age=864000;
5    }
6
7    if ($request_uri ~* "^/linux/|^/t/") {
8      add_header    Cache-Control  max-age=86400;
9    }
```
## 协商缓存
### 协商缓存原理
如果浏览器对某个资源的请求没有命中强缓存，浏览器就不能确定是否能使用已经缓存的资源，这时就需要服务器来决定请求的资源是否过期。如果没有过期或从上次请求之后资源没有更新过，服务器就告诉浏览器依然使用缓存中的资源。这个过程就是浏览器发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的http状态为304，并且会显示一个Not Modified的字符串。协商缓存避免了服务器处理每个请求，提高了服务器性能。
协商缓存利用的是 【Last-Modified, If-Modified-Since】和 【Etag, If-none-Match】这两对 Header来管理。
协商缓存必须配合强缓存使用，不然协商缓存没有意义

### 协商缓存的使用
1. 浏览器第一次向服务器请求一个资源时，服务器在返回资源时会在response header加上 Last-modified这个header，表示这个资源在服务器上的最后修改时间;
![](http://images2015.cnblogs.com/blog/459873/201601/459873-20160115111438210-1551540589.png)

2. 浏览器再次向服务器请求这个资源时，会在request header中加上 If-modified-since这个header，这个header的值就是上次请求返回的Last-modified的值。
![](http://images2015.cnblogs.com/blog/459873/201601/459873-20160115125437460-1062702620.png)

3. 服务器再次收到这个资源的请求时，根据浏览器传过来的 Last-Modified-Since和资源在服务器上的最后修改时间做对比，如果没有变化就返回 304 Not Modified，这是告诉浏览器去缓存中获取资源，服务器不会返回资源内容；如果有变化就正常返回资源内容。当服务器返回 304 Not Modified的相应时，response header 中不会再添加Last-Modified的header，因为既然资源没有改变，Last-modified也就不会改变。

4. 如果协商缓存没有命中，浏览器需要直接从服务器加载资源，这时服务器 response header中会添加 Last-Modified的header，相应的，浏览器会记录 Last-Modified的值，下次请求时 If-Modified-Since会返回最新获取的 Last-Modified的值。

### 【ETag、If-None-Match】 header的使用
【Last-Modified，If-Modified-Since】都是根据服务器时间返回的header，一般来说，在没有调整服务器时间和篡改客户端缓存的情况下，这两个header配合起来管理协商缓存是非常可靠的，但是有时候也会服务器上资源其实有变化，但是最后修改时间却没有变化的情况，而这种问题又很不容易被定位出来，而当这种情况出现的时候，就会影响协商缓存的可靠性。所以就有了另外一对header来管理协商缓存，这对header就是【ETag、If-None-Match】。它们的缓存管理的方式是：

1. 浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上ETag的header，这个header是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，只要资源有变化这个串就不同，跟最后修改时间没有关系，所以能很好的补充Last-Modified的问题：
![](http://images2015.cnblogs.com/blog/459873/201601/459873-20160115112627835-440813422.png)

2. 浏览器再次跟服务器请求这个资源时，在request的header上加上If-None-Match的header，这个header的值就是上一次请求时返回的ETag的值：
![](http://images2015.cnblogs.com/blog/459873/201601/459873-20160115112635850-559297790.png)

3. 服务器再次收到资源请求时，根据浏览器传过来If-None-Match和然后再根据资源生成一个新的ETag，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化：
![](http://images2015.cnblogs.com/blog/459873/201601/459873-20160115125438928-1048294855.png)

### 协商缓存的管理
【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】一般都是同时启用，这是为了处理Last-Modified不可靠的情况。有一种场景需要注意：
分布式系统里多台机器间文件的Last-Modified必须保持一致，以免负载均衡到不同机器导致比对失败；
分布式系统尽量关闭掉ETag(每台机器生成的ETag都会不一样）；

## 浏览器行为对缓存的影响

如果资源已经被浏览器缓存下来，在缓存失效之前，再次请求时，默认会先检查是否命中强缓存，如果强缓存命中则直接读取缓存，如果强缓存没有命中则发请求到服务器检查是否命中协商缓存，如果协商缓存命中，则告诉浏览器还是可以从缓存读，否则才从服务器返回最新的资源。这是默认的处理方式，这个方式可能被浏览器的行为改变：
1. 当ctrl+f5强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；
2. 当f5刷新网页时，跳过强缓存，但是会检查协商缓存.

